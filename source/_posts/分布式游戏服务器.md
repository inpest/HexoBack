---
title: 分布式游戏服务器
date: 2020-2-25 22:30:15
categories: 
- Unity
- ET框架学习笔记
tags: 
- 知识科普
- ET
---
<!-- more -->
# 游戏服务器发展史
## 早期的网络服务器架构
最早人们对于游戏这种消遣的服务程序并不是有追求，因为不是生活必需品，如果连吃饱饭都是个问题那么更不用想买电脑、手机玩游戏了，早期游戏种类基本就是卡牌和跑酷，这种游戏对于实时性需求不高，PK时并不需要面对面，打一下对方的离线数据，更新下排行榜，买买道具啥的，每天上限收收菜这种实现十分简单，所以大多数人选择弱连接的HTTP服务器，登录时使用非对称加密，服务器根据客户端的UID、时间戳、服务端私钥计算哈希值得到加密的Key传给客户端，客户端保存Key在内存中用于之后通信，服务端不需要存Key，它采取每次连接都计算一边哈希值保证连接的是同一个客户端

每局开始时访问一下服务器请求关卡数据，一局结束后再一次请求服务器结算，后端数据库采用MySql或者Mongo，也许还有些游戏使用Redis做缓存，如果需要聊天、通知等功能就设置轮询，比如15秒请求一次如果有消息就取下来，没有可以放长轮询时间比如20秒、30秒，对于这样聊天有些延迟也能适应 这种服务器在早期实现三国策略卡牌或者跑酷绰绰有余，因为逻辑简单用户间交互不强，而且Http开发速度快用一个浏览器就能调试清楚了

![Http服务器模型](https://s1.ax1x.com/2020/05/17/YRYHSS.png)
## 第一代游戏服务器
世界上最早的真正意义上的网络服务器是1978年，英国的财经学校Univesity of Essex的学生 Roy Trubshaw编写了世界上第一个MUD程序，名叫\<MUD1>这是一种文字冒险类游戏，没有任何的图片，玩家可以在游戏中冒险和交流，对比于以往有联机功能的游戏，MUD1可以保证多人实时交互，即使退出游戏重新登录或者服务器重启也会保持上次退出时后的状态

随着MUD1的作者将源码公开，MUD在游戏领域越来越受欢迎，在1991年的时候在MUD1的基础上产生了开源框架 MudOS，成为了众多网游的鼻祖，它的特点是:
- 采用C语言开发
- 采用单线程无阻塞的套接字来服务玩家
- 所有玩家的请求都发到同一个线程去处理
- 主线程每隔1s更新一次所有对象

MUD游戏世界采用房间的组织方式，用户使用Telnet(应用层的一个协议属于TCP/IP协议族)之类的客户端通过Tcp协议连接到MudOS上，使用纯文字进行游戏，每条指令用回车分割。在当时这种服务器可以承载4000个客户端同时在线。自从1991年MudOS出现后，全球相继出现各种为他改进、扩充的新版本，在早期MUD1中只有17个房间，Roy毕业后将项目交给学弟，学弟不断扩充Mud玩法，后来发展到100多个房间

当时游戏内容可以通过LPC脚本进行定制，LPC是一种面向对象的解释性语言，但是他却没有类的概念，但当时的人们能够开发出这种语言可比我们写写lua脚本厉害多了，LPC是基于C语言修改的，维护一个C语言的函数库想想就是一个很巨大的工程

在1992年时候MUD传入中国，当时第一个国产MUD是由张英豪开发的\<Formosa>，不过当时不支持输入中文，后来MUD越来越受欢迎，最出名的是方舟子制作出的\<侠客行>由金庸先生的小说为蓝本制作，受到了很大程度的欢迎，即使到了现在2020年在各种小游戏平台上我们依然还可以看到MUD的影子，TapTap上很多这种类型的游戏，仍然有很多人在闲暇时间玩得乐此不疲

![早期MUD](https://s1.ax1x.com/2020/05/17/YR3O58.png)

而这种MudOS的服务器架构也一直为第一代MMORPG提供了稳固的支持，直到2003年，依然还有使用MudOS开发的游戏

## 第二代游戏服务器 2003
### 最初形态
随着MUD游戏的发展，2000年后网络游戏开始进入全图形化界面的时代，最开始承受不住的是小文件，用户频繁上下线读写数据导致负载越来越大，早期的EXT磁盘分区比较脆弱，稍微停电就容易引发大面积数据丢失，因为磁盘存储数据很容易就产生空间浪费，一个区块常常会含有一小块没法用来存储(因为操作系统的文件存储规则)所以我们要把数据存储到数据库中，而这是我们也用更高级的面向对象的脚本语言Python或者Lua(元表实现面向对象)来代替LPC
### 第二形态
由于但服对于大规模用户还是存在瓶颈，所以第二代服务器模型出现，将服务器拆成多个世界服务器，每个服务器都是一个不同的世界，不同的世界老死不相往来，这就是区服概念的由来 这种服务器一定程度上缓解了一个服务器的压力，对于开发者是好那么一点了，但是对于玩家来说，游戏刚开区还可以，我们经常晚一些MMORPG游戏刚开服基本都是爆满，随着时间推移，由于游戏本身、玩家意愿等问题导致玩家脱坑(就是不玩了)那么服务器就会变得人很少，玩家进个副本没人打怪的情况就出现了，后来玩家们就开始呼吁要跨服战，要转移到人多的服务器，后面就出现了合区、合服的概念，游戏厂商以此还将其变成了一种运营手段，现在一般页游都是这样开几百个服最后慢慢合
### 第三形态
这种服务器架构还带来一些数据库访问的问题，由于两个服务器有时候都需要一份相同的数据那么就要会引起大量的数据重复读的问题，然后为了解决这种问题衍生出第三形态，在数据库与区服之间建立一个代理服务器，负责存储一些某个服务器已经读取过的数据，这时另一个服务器再向DB请求数据的时候会先向代理服务器请求，如果没有则代理服务器去DB中查询，在代理服务器中提供了内存级别的Cache所以访问速度非常快，解决了大量数据交换的问题，而且在早期的数据库没有DB存储过程(类似于函数)功能所以开发人员可以在网关服务器编写类似存储过程的函数便于方便向DB查询数据
### 第四形态
第三形态的服务器模型没有持续太久，因为对于服务器之间交换数据比较麻烦，而且容易错乱，所以人们拆分了网络功能，独立出一个叫做Gate的服务器(网关服务器)，人们在连接时先去统一连接Gate服务器，再由Gate服务器去向服务器请求数据，而服务器间的数据交换也由Gate服务器进行转发
### 线程调度
游戏分区服虽然可以解决服务器扩展的瓶颈，但一台服务器以单线程的方式运行不能充分利用系统资源，而且大量分区使得服务器开销变大，这时出现了两种线程模型
- 单进程多线程
这种方式有一个缺点就是因为线程间的变量是共享的，这样很容易造成死锁问题，所以这种线程模型使用时要十分小心
- 单线程多进程
这种多进程是比较推荐的做法，因为每个进程间相互独立，所以很简单把逻辑分离开
两种方式都是对多核CPU的充分利用大大节省了成本

## 第三代游戏服务器 2007
人们意识到了似乎将服务器拆的越开，对于性能就越有提升，于是开始拆分各种能拆分的服务器，网关、聊天、地图等等每个功能都拆分出一个服务器来管理，最后类似于魔兽世界中的无缝世界地图，这种是把世界的场景管理也分开了将每块地方都设计成节点，每个节点就是一个节点服务器负责管理这块区域的玩家信息，而节点统一由一个节点管理服务器管理，这种管理方法可以进行负载均衡，人多的地方节点管理的区域就设置小一点，人少的地方节点管理区域就设置大一点，完全可以动态改变
## 后来服务器发展
现在可以看出服务器发展一直围绕着一个核心概念，就是拆，如果一个服承载不下那就两个，两个不够就三个，渐渐的就成为了分布式游戏服务器的架构，再后来 有拆分出了 对象服务器拆分的更加细致 对于大型游戏来说，项目规模越大，拆分的越细
## 其他服务器模型
对于其他种类游戏也有不同的服务器模型
- 开房间式游戏服务器
这种游戏服务器也非常的典型，例如LOL、DOTA、皇室战争、王者荣耀等，这些游戏房间与房间没有联系，只需要管理房间的玩家就可以了，一般这种是以一个人为host其他人都以P2P的方式连接到这个人身上形成一种星形的结构
- 现代副本类型的服务器
这种服务器类似于RPG+开房间的服务器玩家进入副本时候是单独开房间，而回到城镇又变成世界服，这种也很常见
# ET框架的服务器
ET框架属于一种单线程多进程的分布式服务器架构，当然你也可能之开一台服务器，可以从控制台随意更改配置，扩展性十分灵活，它是由一个Manager服务器来读取命令行配置信息来进一步开启其他服务器，而且携带服务器挂掉还能重启的功能具体还没研究到那，而且支持服务器的热重启(也就是所谓的不停服更新=>这里指的是不单单不停客户端而且不停服务器)反正就是十分强大，如果还没有了解ET的希望可以去看看代码，会很有收获
# 结束语
因为时间关系 今天就说这么多，如果有错误可以在评论区指正
# 参考文章
游戏服务器架构发展史:https://blog.csdn.net/u010852160/article/details/51917014